// 动态规划
// 找规律，找到dp[n]（整数n能组成的二叉树的个数）的公式
// dp[n] = 节点[1]为头节点搜索树的数量 + 节点[2]为头节点搜索树的数量 + ...... + 节点[n]为头节点搜索树的数量.
// dp[3] = 节点[1]为头节点搜索树的数量 + 节点[2]为头节点搜索树的数量 + 节点[3]为头节点搜索树的数量
// 当[1]为头节点时: 左子树有0个元素的搜索树数量 * 右子树有2个元素的搜索树数量。
// 当[2]为头节点时：左子树有1个元素的搜索树数量 * 右子树有1个元素的搜索树数量。
// 当[1]为头节点时：左子树有2个元素的搜索树数量 * 右子树有1个元素的搜索树数量。
// 其中，
// 有两个元素的搜索树数量就是dp[2].
// 有一个个元素的搜索树数量就是dp[1].
// 有0个元素的搜索树数量就是dp[0].

// dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0];

// dp数组初始化：dp[0] = 1, dp[1] = 1;
// 遍历顺序：从1遍历到n
// 内部从1遍历到i： dp[i] += dp[j - 1] * dp[i - j];

function numTrees(n: number): number {
  const dp = new Array(n + 1).fill(0);
  dp[0] = [1];
  dp[1] = [1];
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }
  return dp[n];
}
